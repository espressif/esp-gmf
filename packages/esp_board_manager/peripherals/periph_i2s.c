/*
 * SPDX-FileCopyrightText: 2025 Espressif Systems (Shanghai) CO., LTD
 * SPDX-License-Identifier: LicenseRef-Espressif-Modified-MIT
 *
 * See LICENSE file for details.
 */

#include "periph_i2s.h"
#include <stdlib.h>
#include <string.h>
#include "esp_log.h"

static const char *TAG = "PERIPH_I2S";

typedef struct {
    i2s_chan_handle_t  chan_in;
    i2s_chan_handle_t  chan_out;
    uint8_t            in_en:1;
    uint8_t            out_en:1;
} periph_i2s_chan_t;

static periph_i2s_chan_t i2s_chan_handles[SOC_I2S_NUM] = {0};

int periph_i2s_init(void *cfg, int cfg_size, void **periph_handle)
{
    if (!cfg || !periph_handle || cfg_size < sizeof(periph_i2s_config_t)) {
        ESP_LOGE(TAG, "Invalid parameters");
        return -1;
    }
    periph_i2s_config_t *config = (periph_i2s_config_t *)cfg;
    if (config->port >= SOC_I2S_NUM) {
        ESP_LOGE(TAG, "Port number is invalid, %d", config->port);
        return -1;
    }
    esp_err_t err = ESP_OK;
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(config->port, config->role);
    chan_cfg.auto_clear = true;

    /**
     * NOTE
     * I2S Clock is generated by TX, so if TX is not initialized, the I2S clock will not be generated.
     * So we need to initialize TX and RX at the same time.
     * Then deinit TX will stop the I2S clock, so we need to deinit RX and TX at the same time.
     * This limitation can be resolved after I2S support full-duplex mode automatically.
     **/
    if (i2s_chan_handles[config->port].chan_out == NULL && i2s_chan_handles[config->port].chan_in == NULL) {
        err = i2s_new_channel(&chan_cfg, &i2s_chan_handles[config->port].chan_out, &i2s_chan_handles[config->port].chan_in);
    }
    if (config->mode == I2S_COMM_MODE_STD) {
        if (config->direction == I2S_DIR_TX && !i2s_chan_handles[config->port].out_en) {
            err = i2s_channel_init_std_mode(i2s_chan_handles[config->port].chan_out, &config->i2s_cfg.std);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_out);
            i2s_chan_handles[config->port].out_en = true;
        }
        if (config->direction == I2S_DIR_RX && !i2s_chan_handles[config->port].in_en) {
            if (i2s_chan_handles[config->port].out_en == false) {
                err = i2s_channel_init_std_mode(i2s_chan_handles[config->port].chan_out, &config->i2s_cfg.std);
                err = i2s_channel_enable(i2s_chan_handles[config->port].chan_out);
                i2s_chan_handles[config->port].out_en = true;
            }
            err = i2s_channel_init_std_mode(i2s_chan_handles[config->port].chan_in, &config->i2s_cfg.std);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_in);
            i2s_chan_handles[config->port].in_en = true;
        } else {
            ESP_LOGW(TAG, "I2S STD already enabled, tx:%p, rx:%p", i2s_chan_handles[config->port].chan_out, i2s_chan_handles[config->port].chan_in);
        }
        ESP_LOGI(TAG, "STD, %s, ws: %d, bclk: %d, dout: %d, din: %d",
                    config->direction == I2S_DIR_TX ? " TX" : "RX", config->i2s_cfg.std.gpio_cfg.ws, config->i2s_cfg.std.gpio_cfg.bclk,
                    config->i2s_cfg.std.gpio_cfg.dout, config->i2s_cfg.std.gpio_cfg.din);
    } else if (config->mode == I2S_COMM_MODE_TDM) {
        if (config->direction == I2S_DIR_TX && !i2s_chan_handles[config->port].out_en) {
            err = i2s_channel_init_tdm_mode(i2s_chan_handles[config->port].chan_out, &config->i2s_cfg.tdm);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_out);
            i2s_chan_handles[config->port].out_en = true;
        } else if (config->direction == I2S_DIR_RX && !i2s_chan_handles[config->port].in_en) {
            if (i2s_chan_handles[config->port].out_en == false) {
                err = i2s_channel_init_tdm_mode(i2s_chan_handles[config->port].chan_out, &config->i2s_cfg.tdm);
                err = i2s_channel_enable(i2s_chan_handles[config->port].chan_out);
                i2s_chan_handles[config->port].out_en = true;
            }
            err = i2s_channel_init_tdm_mode(i2s_chan_handles[config->port].chan_in, &config->i2s_cfg.tdm);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_in);
            i2s_chan_handles[config->port].in_en = true;
        } else {
            ESP_LOGW(TAG, "I2S TDM already enabled, tx:%p, rx:%p", i2s_chan_handles[config->port].chan_out, i2s_chan_handles[config->port].chan_in);
        }
        ESP_LOGI(TAG, "TDM, %s, ws: %d, bclk: %d, dout: %d, din: %d",
                    config->direction == I2S_DIR_TX ? " TX" : "RX", config->i2s_cfg.tdm.gpio_cfg.ws, config->i2s_cfg.tdm.gpio_cfg.bclk,
                    config->i2s_cfg.tdm.gpio_cfg.dout, config->i2s_cfg.tdm.gpio_cfg.din);
    } else if (config->mode == I2S_COMM_MODE_PDM) {
        if (config->direction == I2S_DIR_TX && !i2s_chan_handles[config->port].out_en) {
            err = i2s_channel_init_pdm_tx_mode(i2s_chan_handles[config->port].chan_out, &config->i2s_cfg.pdm_tx);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_out);
            i2s_chan_handles[config->port].out_en = true;
            ESP_LOGI(TAG, "PDM-TX, clk: %d, dout: %d", config->i2s_cfg.pdm_tx.gpio_cfg.clk, config->i2s_cfg.pdm_tx.gpio_cfg.dout);
        } else if (config->direction == I2S_DIR_RX && !i2s_chan_handles[config->port].in_en) {
            err = i2s_channel_init_pdm_rx_mode(i2s_chan_handles[config->port].chan_in, &config->i2s_cfg.pdm_rx);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_in);
            i2s_chan_handles[config->port].in_en = true;
            ESP_LOGI(TAG, "PDM-RX, clk: %d, din: %d", config->i2s_cfg.pdm_rx.gpio_cfg.clk, config->i2s_cfg.pdm_rx.gpio_cfg.din);
        } else {
            ESP_LOGW(TAG, "I2S PDM already enabled, tx:%p, rx:%p", i2s_chan_handles[config->port].chan_out, i2s_chan_handles[config->port].chan_in);
        }
    } else {
        ESP_LOGE(TAG, "Invalid I2S mode: %d", config->mode);
        return -1;
    }
    if (err != ESP_OK) {
        if (i2s_chan_handles[config->port].chan_in) {
            i2s_del_channel(i2s_chan_handles[config->port].chan_in);
        }
        i2s_chan_handles[config->port].chan_in = NULL;
        i2s_chan_handles[config->port].in_en = false;
        if (i2s_chan_handles[config->port].chan_out) {
            i2s_del_channel(i2s_chan_handles[config->port].chan_out);
        }
        i2s_chan_handles[config->port].chan_out = NULL;
        i2s_chan_handles[config->port].out_en = false;
        ESP_LOGE(TAG, "i2s_channel_init failed: %d", err);
        return -1;
    }
    if (config->direction == I2S_DIR_TX) {
        *periph_handle = i2s_chan_handles[config->port].chan_out;
    } else if (config->direction == I2S_DIR_RX) {
        *periph_handle = i2s_chan_handles[config->port].chan_in;
    } else {
        ESP_LOGE(TAG, "Invalid direction: %d", config->direction);
        return -1;
    }
    ESP_LOGI(TAG, "i2s_channel_init success: %p", *periph_handle);
    return 0;
}

int periph_i2s_deinit(void *periph_handle)
{
    if (!periph_handle) {
        ESP_LOGE(TAG, "Invalid handle");
        return -1;
    }
    i2s_chan_handle_t handle = (i2s_chan_handle_t)periph_handle;
    for (size_t i = 0; i < SOC_I2S_NUM; i++) {
        if (i2s_chan_handles[i].chan_out == handle) {
            i2s_del_channel(i2s_chan_handles[i].chan_out);
            i2s_chan_handles[i].chan_out = NULL;
            i2s_chan_handles[i].out_en = false;
            ESP_LOGW(TAG, "Caution: Releasing TX (%p), RX (%p) forced to stop.",
                     i2s_chan_handles[i].chan_out, i2s_chan_handles[i].chan_in);
            i2s_channel_disable(i2s_chan_handles[i].chan_in);
            i2s_del_channel(i2s_chan_handles[i].chan_in);
            i2s_chan_handles[i].chan_in = NULL;
            i2s_chan_handles[i].in_en = false;
        }
        if (i2s_chan_handles[i].chan_in == handle) {
            i2s_del_channel(i2s_chan_handles[i].chan_in);
            i2s_chan_handles[i].chan_in = NULL;
            i2s_chan_handles[i].in_en = false;
            ESP_LOGW(TAG, "Caution: Releasing RX (%p), TX (%p) forced to stop.",
                     i2s_chan_handles[i].chan_in, i2s_chan_handles[i].chan_out);
            i2s_channel_disable(i2s_chan_handles[i].chan_out);
            i2s_del_channel(i2s_chan_handles[i].chan_out);
            i2s_chan_handles[i].chan_out = NULL;
            i2s_chan_handles[i].out_en = false;
        }
    }
    return 0;
}
