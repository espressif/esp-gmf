/*
 * SPDX-FileCopyrightText: 2025 Espressif Systems (Shanghai) CO., LTD
 * SPDX-License-Identifier: LicenseRef-Espressif-Modified-MIT
 *
 * See LICENSE file for details.
 */

#include "periph_i2s.h"
#include <stdlib.h>
#include <string.h>
#include "esp_log.h"

static const char *TAG = "PERIPH_I2S";

typedef struct {
    i2s_chan_handle_t  chan_in;     /*!< I2S input channel handle */
    i2s_chan_handle_t  chan_out;    /*!< I2S output channel handle */
    uint8_t            in_en  : 1;  /*!< Input channel enable flag */
    uint8_t            out_en : 1;  /*!< Output channel enable flag */
} periph_i2s_chan_t;

periph_i2s_chan_t i2s_chan_handles[SOC_I2S_NUM] = {0};

int periph_i2s_init(void *cfg, int cfg_size, void **periph_handle)
{
    if (!cfg || !periph_handle || cfg_size < sizeof(periph_i2s_config_t)) {
        ESP_LOGE(TAG, "Invalid parameters");
        return -1;
    }
    periph_i2s_config_t *config = (periph_i2s_config_t *)cfg;
    if (config->port >= SOC_I2S_NUM) {
        ESP_LOGE(TAG, "Port number is invalid, %d", config->port);
        return -1;
    }
    esp_err_t err = ESP_OK;
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(config->port, config->role);
    chan_cfg.auto_clear = true;

    /**
     * NOTE
     * I2S Clock is generated by TX, so if TX is not initialized, the I2S clock will not be generated.
     * So we need to initialize TX and RX at the same time.
     * Then deinit TX will stop the I2S clock, so we need to deinit RX and TX at the same time.
     * This limitation can be resolved after I2S support full-duplex mode automatically.
     **/
    if (i2s_chan_handles[config->port].chan_out == NULL && i2s_chan_handles[config->port].chan_in == NULL) {
        err = i2s_new_channel(&chan_cfg, &i2s_chan_handles[config->port].chan_out, &i2s_chan_handles[config->port].chan_in);
    }
    if (config->mode == I2S_COMM_MODE_STD) {
        if (config->direction == I2S_DIR_TX && !i2s_chan_handles[config->port].out_en) {
            err = i2s_channel_init_std_mode(i2s_chan_handles[config->port].chan_out, &config->i2s_cfg.std);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_out);
            i2s_chan_handles[config->port].out_en = true;
        }
        if (config->direction == I2S_DIR_RX && !i2s_chan_handles[config->port].in_en) {
            if (i2s_chan_handles[config->port].out_en == false) {
                err = i2s_channel_init_std_mode(i2s_chan_handles[config->port].chan_out, &config->i2s_cfg.std);
                err = i2s_channel_enable(i2s_chan_handles[config->port].chan_out);
                i2s_chan_handles[config->port].out_en = true;
            }
            err = i2s_channel_init_std_mode(i2s_chan_handles[config->port].chan_in, &config->i2s_cfg.std);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_in);
            i2s_chan_handles[config->port].in_en = true;
        } else {
            ESP_LOGW(TAG, "I2S[%d] STD already enabled, tx:%p, rx:%p", config->port, i2s_chan_handles[config->port].chan_out, i2s_chan_handles[config->port].chan_in);
        }
        ESP_LOGI(TAG, "I2S[%d] STD, %s, ws: %d, bclk: %d, dout: %d, din: %d", config->port,
                 config->direction == I2S_DIR_TX ? " TX" : "RX", config->i2s_cfg.std.gpio_cfg.ws, config->i2s_cfg.std.gpio_cfg.bclk,
                 config->i2s_cfg.std.gpio_cfg.dout, config->i2s_cfg.std.gpio_cfg.din);
    }
#if CONFIG_SOC_I2S_SUPPORTS_TDM
    else if (config->mode == I2S_COMM_MODE_TDM) {
        if (config->direction == I2S_DIR_TX && !i2s_chan_handles[config->port].out_en) {
            err = i2s_channel_init_tdm_mode(i2s_chan_handles[config->port].chan_out, &config->i2s_cfg.tdm);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_out);
            i2s_chan_handles[config->port].out_en = true;
        } else if (config->direction == I2S_DIR_RX && !i2s_chan_handles[config->port].in_en) {
            if (i2s_chan_handles[config->port].out_en == false) {
                err = i2s_channel_init_tdm_mode(i2s_chan_handles[config->port].chan_out, &config->i2s_cfg.tdm);
                err = i2s_channel_enable(i2s_chan_handles[config->port].chan_out);
                i2s_chan_handles[config->port].out_en = true;
            }
            err = i2s_channel_init_tdm_mode(i2s_chan_handles[config->port].chan_in, &config->i2s_cfg.tdm);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_in);
            i2s_chan_handles[config->port].in_en = true;
        } else {
            ESP_LOGW(TAG, "I2S[%d] TDM already enabled, tx:%p, rx:%p", config->port, i2s_chan_handles[config->port].chan_out, i2s_chan_handles[config->port].chan_in);
        }
        ESP_LOGI(TAG, "I2S[%d] TDM, %s, ws: %d, bclk: %d, dout: %d, din: %d", config->port,
                 config->direction == I2S_DIR_TX ? " TX" : "RX", config->i2s_cfg.tdm.gpio_cfg.ws, config->i2s_cfg.tdm.gpio_cfg.bclk,
                 config->i2s_cfg.tdm.gpio_cfg.dout, config->i2s_cfg.tdm.gpio_cfg.din);
    }
#endif  // CONFIG_SOC_I2S_SUPPORTS_TDM
#if CONFIG_SOC_I2S_SUPPORTS_PDM
    else if (config->mode == I2S_COMM_MODE_PDM) {
        if (config->direction == I2S_DIR_TX && !i2s_chan_handles[config->port].out_en) {
#if CONFIG_SOC_I2S_SUPPORTS_PDM_TX
            err = i2s_channel_init_pdm_tx_mode(i2s_chan_handles[config->port].chan_out, &config->i2s_cfg.pdm_tx);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_out);
            i2s_chan_handles[config->port].out_en = true;
            ESP_LOGI(TAG, "I2S[%d] PDM-TX, clk: %d, dout: %d", config->port, config->i2s_cfg.pdm_tx.gpio_cfg.clk, config->i2s_cfg.pdm_tx.gpio_cfg.dout);
#endif  // CONFIG_SOC_I2S_SUPPORTS_PDM_TX
        } else if (config->direction == I2S_DIR_RX && !i2s_chan_handles[config->port].in_en) {
#if CONFIG_SOC_I2S_SUPPORTS_PDM_RX
            err = i2s_channel_init_pdm_rx_mode(i2s_chan_handles[config->port].chan_in, &config->i2s_cfg.pdm_rx);
            err = i2s_channel_enable(i2s_chan_handles[config->port].chan_in);
            i2s_chan_handles[config->port].in_en = true;
            ESP_LOGI(TAG, "I2S[%d] PDM-RX, clk: %d, din: %d", config->port, config->i2s_cfg.pdm_rx.gpio_cfg.clk, config->i2s_cfg.pdm_rx.gpio_cfg.din);
#endif  // CONFIG_SOC_I2S_SUPPORTS_PDM_RX
        } else {
            ESP_LOGW(TAG, "I2S[%d] PDM already enabled, tx:%p, rx:%p", config->port, i2s_chan_handles[config->port].chan_out, i2s_chan_handles[config->port].chan_in);
        }
    }
#endif  // CONFIG_SOC_I2S_SUPPORTS_PDM
    else {
        ESP_LOGE(TAG, "I2S[%d] Invalid mode: %d", config->port, config->mode);
        return -1;
    }
    if (err != ESP_OK) {
        if (i2s_chan_handles[config->port].chan_in) {
            i2s_del_channel(i2s_chan_handles[config->port].chan_in);
        }
        i2s_chan_handles[config->port].chan_in = NULL;
        i2s_chan_handles[config->port].in_en = false;
        if (i2s_chan_handles[config->port].chan_out) {
            i2s_del_channel(i2s_chan_handles[config->port].chan_out);
        }
        i2s_chan_handles[config->port].chan_out = NULL;
        i2s_chan_handles[config->port].out_en = false;
        ESP_LOGE(TAG, "I2S[%d] initialize failed: %d", config->port, err);
        return -1;
    }
    if (config->direction == I2S_DIR_TX) {
        *periph_handle = i2s_chan_handles[config->port].chan_out;
    } else if (config->direction == I2S_DIR_RX) {
        *periph_handle = i2s_chan_handles[config->port].chan_in;
    } else {
        ESP_LOGE(TAG, "I2S[%d] Invalid direction: %d", config->port, config->direction);
        return -1;
    }
    ESP_LOGI(TAG, "I2S[%d] initialize success: %p", config->port, *periph_handle);
    return 0;
}

int periph_i2s_deinit(void *periph_handle)
{
    if (!periph_handle) {
        ESP_LOGE(TAG, "Invalid handle");
        return -1;
    }
    i2s_chan_handle_t handle = (i2s_chan_handle_t)periph_handle;
    for (size_t i = 0; i < SOC_I2S_NUM; i++) {
        if (i2s_chan_handles[i].chan_out == handle) {
            i2s_channel_disable(i2s_chan_handles[i].chan_out);
            i2s_del_channel(i2s_chan_handles[i].chan_out);
            i2s_chan_handles[i].chan_out = NULL;
            i2s_chan_handles[i].out_en = false;
            ESP_LOGW(TAG, "Caution: Releasing TX (%p).", i2s_chan_handles[i].chan_out);
            if (i2s_chan_handles[i].chan_in != NULL && i2s_chan_handles[i].in_en == false) {
                ESP_LOGW(TAG, "Caution: RX (%p) forced to stop.", i2s_chan_handles[i].chan_in);
                i2s_channel_disable(i2s_chan_handles[i].chan_in);
                i2s_del_channel(i2s_chan_handles[i].chan_in);
                i2s_chan_handles[i].chan_in = NULL;
            }
        }
        if (i2s_chan_handles[i].chan_in == handle) {
            i2s_channel_disable(i2s_chan_handles[i].chan_in);
            i2s_del_channel(i2s_chan_handles[i].chan_in);
            i2s_chan_handles[i].chan_in = NULL;
            i2s_chan_handles[i].in_en = false;
            ESP_LOGW(TAG, "Caution: Releasing RX (%p).", i2s_chan_handles[i].chan_in);
            if (i2s_chan_handles[i].chan_out != NULL && i2s_chan_handles[i].out_en == false) {
                ESP_LOGW(TAG, "Caution: TX (%p) forced to stop.", i2s_chan_handles[i].chan_out);
                i2s_channel_disable(i2s_chan_handles[i].chan_out);
                i2s_del_channel(i2s_chan_handles[i].chan_out);
                i2s_chan_handles[i].chan_out = NULL;
            }
        }
    }
    return 0;
}
